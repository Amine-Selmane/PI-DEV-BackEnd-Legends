'use strict';


function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

function CorkedRequest(state) {
  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(this, state);
  };
}

const asyncWrite = process.nextTick;

function validChunk(stream, state, chunk, cb) {
  if (chunk === null) {
    const er = new TypeError('May not write null values to stream');
    stream.emit('error', er);
    process.nextTick(cb, er);
    return false;
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    const er = new TypeError('Invalid non-string/buffer chunk');
    stream.emit('error', er);
    process.nextTick(cb, er);
    return false;
  }
  return true;
}

function writeAfterEnd(stream, cb) {
  const er = new Error('write after end');
  process.nextTick(cb, er);
  stream.emit('error', er);
}

function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    chunk = Buffer.from(chunk, encoding);
    encoding = '';
  }

  const len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  const ret = state.length < state.highWaterMark;
  if (!ret) {
    state.needDrain = true;
  }

  if (state.writing || state.corked) {
    const last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk,
      encoding,
      isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwrite(stream, er) {
  const state = stream._writableState;
  const sync = state.sync;
  const cb = state.writecb;

  state.writing = false;
  state.writecb = null;
  state.writelen = 0;

  if (er) {
    errorOrDestroy(stream, er);
  }

  if (cb) {
    if (sync) {
      process.nextTick(cb, er);
    } else {
      cb(er);
    }
  }

  const lastBufferedRequest = state.lastBufferedRequest;
  if (lastBufferedRequest) {
    state.lastBufferedRequest = lastBufferedRequest.next;
    if (!state.lastBufferedRequest) {
      state.bufferedRequest = null;
    }
    onwrite(stream, lastBufferedRequest.chunk, lastBufferedRequest.encoding, lastBufferedRequest.callback);
  }

  maybeBufferedRequest(stream, state);
}

function maybeBufferedRequest(stream, state) {
  if (state.bufferedRequestCount && !state.writing) {
    state.bufferedRequestCount--;
    doWrite(
      stream,
      state,
      false,
      state.lastBufferedRequest.chunk,
      state.lastBufferedRequest.encoding,
      state.lastBufferedRequest.callback
    );
    state.lastBufferedRequest = null;
  }
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) process.nextTick(cb);
    else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

function finishMaybe(stream, state) {
  const need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
      if (state.autoDestroy) {
        const rState = stream._readableState;
        if (!rState || (rState.autoDestroy && rState.endEmitted)) {
          stream.destroy();
        }
      }
    }
  }
  return need;
}

function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function' && !state.destroyed) {
      state.pendingcb++;
      state.finalCalled = true;
      process.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function callFinal(stream, state) {
  stream._final(err => {
    state.pendingcb--;
    if (err) {
      errorOrDestroy(stream, err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}

function onCorkedFinish(corkReq, state, err) {
  let entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    const cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }
  state.corkedRequestsFree.next = corkReq;
}

const WritableState = {
  getBuffer: function getBuffer() {
    const current = this.bufferedRequest;
    const out = [];
    while (current) {
      out.push(current);
      current = current.next;
    }
    return out;
  }
};

function Writable(options) {
  if (!(this instanceof Writable)) {
    return new Writable(options);
  }

  const Duplex = require('./_stream_duplex');
  if (!Duplex) {
    throw new Error('Duplex stream module is missing');
  }

  this._writableState = new WritableState(options, this);

  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }

  Writable.super_.call(this);
}

Object.setPrototypeOf(Writable.prototype, WritableState);
Object.setPrototypeOf(Writable, WritableState);

Writable.prototype.write = function (chunk, encoding, cb) {
  const state = this._writableState;
  const ret = false;
  const isBuf = Buffer.isBuffer(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = Buffer.from(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (typeof cb !== 'function') cb = () => {};

  if (state.ended) writeAfterEnd(this, cb);
  else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype.end = function (chunk, encoding, cb) {
  const state = this._writableState;
  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }
  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }
  if (!state.ending) endWritable(this, state, cb);
  return this;
};

module.exports = Writable;
